{"version":3,"sources":["../../src/option_result.ts","../../src/to_option.ts","../../src/get_result.ts","../../src/unwrap.ts","../../src/unwrap_or.ts","../../src/unwrap_or_else.ts"],"sourcesContent":["/**\n * An implementation of `Result` from Rust stdlib\n *\n * https://doc.rust-lang.org/std/result/enum.Result.html\n */\nexport type Result<R, E> = Readonly<{\n\t/**\n\t * ```ts\n\t * Ok('foo').isOk(); // returns `true`\n\t * Err('foo').isOk(); // returns `false`\n\t * ```\n\t */\n\tisOk: () => boolean;\n\t/**\n\t * ```ts\n\t * Ok(123).isOkAnd((value) => value > 100); // returns `true`\n\t * Ok(12).isOkAnd((value) => value > 100); // returns `false`\n\t * Err(123).isOkAnd((value) => value > 100); // returns `false`\n\t * ```\n\t */\n\tisOkAnd: (fn: (arg: R) => boolean) => boolean;\n\t/**\n\t * ```ts\n\t * Ok('foo').isErr(); // returns `false`\n\t * Err('foo').isErr(); // returns `true`\n\t * ```\n\t */\n\tisErr: () => boolean;\n\t/**\n\t * ```ts\n\t * Ok(123).isErrAnd((value) => value > 100); // returns `false`\n\t * Err(123).isErrAnd((value) => value > 100); // returns `true`\n\t * Err(12).isErrAnd((value) => value > 100); // returns `false`\n\t * ```\n\t */\n\tisErrAnd: (fn: (arg: E) => boolean) => boolean;\n\t/**\n\t * ```ts\n\t * Ok('foo').ok(); // returns `Some('foo')`\n\t * Err('foo').ok(); // returns `None()`\n\t * ```\n\t */\n\tok: () => Option<R>;\n\t/**\n\t * ```ts\n\t * Ok('foo').err(); // returns `None()`\n\t * Err('foo').err(); // returns `Some('foo')`\n\t * ```\n\t */\n\terr: () => Option<E>;\n\t/**\n\t * ```ts\n\t * Ok(1).map((value) => value * 2); // returns `Ok(2)`\n\t * Err(1).map((value) => value * 2); // returns `Err(1)`\n\t * ```\n\t */\n\tmap: <U>(fn: (arg: R) => U) => Result<U, E>;\n\t/**\n\t * ```ts\n\t * Ok(1).mapOr(10, (value) => value * 2); // returns `2`\n\t * Err(1).mapOr(10, (value) => value * 2); // returns `10`\n\t * ```\n\t */\n\tmapOr: <U>(defaultValue: U, fn: (arg: R) => U) => U;\n\t/**\n\t * ```ts\n\t * Ok(1).mapOrElse((err) => err * 10, (value) => value * 2); // returns `2`\n\t * Err(1).mapOrElse((err) => err * 10, (value) => value * 2); // returns `10`\n\t * ```\n\t */\n\tmapOrElse: <U>(getDefaultValue: (arg: E) => U, fn: (arg: R) => U) => U;\n\t/**\n\t * ```ts\n\t * Ok(1).mapErr((err) => err * 2); // returns `Ok(1)`\n\t * Err(1).mapErr((err) => err * 2); // returns `Err(2)`\n\t * ```\n\t */\n\tmapErr: <F>(fn: (arg: E) => F) => Result<R, F>;\n\t/**\n\t * ```ts\n\t * Ok('foo').expect('error message'); // returns `'foo'`\n\t * Err('foo').expect('error message'); // throws `new Error('error message')`\n\t * ```\n\t */\n\texpect: (msg: string) => R;\n\t/**\n\t * ```ts\n\t * Ok('foo').expectErr('error message'); // throws `new Error('error message')`\n\t * Err('foo').expectErr('error message'); // returns `'foo'`\n\t * ```\n\t */\n\texpectErr: (msg: string) => E;\n\t/**\n\t * ```ts\n\t * Ok('foo').unwrap(); // returns `'foo'`\n\t * Err('foo').unwrap(); // throws\n\t * ```\n\t */\n\tunwrap: () => R;\n\t/**\n\t * ```ts\n\t * Ok('foo').unwrapErr(); // throws\n\t * Err('foo').unwrapErr(); // returns `'foo'`\n\t * ```\n\t */\n\tunwrapErr: () => E;\n\t/**\n\t * ```ts\n\t * Ok('foo').unwrapOr('bar'); // returns `'foo'`\n\t * Err('foo').unwrapOr('bar'); // returns `'bar'`\n\t * ```\n\t */\n\tunwrapOr: (defaultValue: R) => R;\n\t/**\n\t * ```ts\n\t * Ok(1).unwrapOrElse('bar'); // returns `1`\n\t * Err(1).unwrapOrElse((err) => err * 2); // returns `2`\n\t * ```\n\t */\n\tunwrapOrElse: (getDefaultValue: (arg: E) => R) => R;\n\t/**\n\t * ```ts\n\t * Ok('foo').and(otherResult); // returns `otherResult`\n\t * Err('foo').and(otherResult); // returns `Err('foo')`\n\t * ```\n\t */\n\tand: <U>(res: Result<U, E>) => Result<U, E>;\n\t/**\n\t * ```ts\n\t * Ok(1).andThen((value) => Ok(value * 2)); // returns `Ok(2)`\n\t * Ok(1).andThen((value) => Err(value * 2)); // returns `Err(2)`\n\t * Err(1).andThen((value) => Ok(value * 2)); // returns `Err(1)`\n\t * ```\n\t */\n\tandThen: <U>(getRes: (arg: R) => Result<U, E>) => Result<U, E>;\n\t/**\n\t * ```ts\n\t * Ok('foo').or(otherResult); // returns `Ok('foo').`\n\t * Err('foo').or(otherResult); // returns `otherResult`\n\t * ```\n\t */\n\tor: <F>(res: Result<R, F>) => Result<R, F>;\n\t/**\n\t * ```ts\n\t * Ok(1).orElse((value) => Ok(value * 2)); // returns `Ok(1)`\n\t * Err(1).orElse((value) => Ok(value * 2)); // returns `Ok(2)`\n\t * Err(1).orElse((value) => Err(value * 2)); // returns `Err(2)`\n\t * ```\n\t */\n\torElse: <F>(getRes: (arg: E) => Result<R, F>) => Result<R, F>;\n}>;\n\n/**\n * @param result The success value\n * @returns The success result\n *\n * https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok\n */\nexport function Ok<R, E>(result: R): Result<R, E> {\n\tconst self: Result<R, E> = {\n\t\tisOk: () => true,\n\t\tisOkAnd: (fn) => fn(result),\n\t\tisErr: () => false,\n\t\tisErrAnd: () => false,\n\t\tok: () => Some(result),\n\t\terr: () => None(),\n\t\tmap: (fn) => Ok(fn(result)),\n\t\tmapOr: (_, fn) => fn(result),\n\t\tmapOrElse: (_, fn) => fn(result),\n\t\tmapErr: () => Ok(result),\n\t\texpect: () => result,\n\t\texpectErr: (msg) => {\n\t\t\tthrow new Error(msg);\n\t\t},\n\t\tunwrap: () => result,\n\t\tunwrapErr: () => {\n\t\t\tthrow new Error(`${result}`);\n\t\t},\n\t\tunwrapOr: () => result,\n\t\tunwrapOrElse: () => result,\n\t\tand: (res) => res,\n\t\tandThen: (getRes) => getRes(result),\n\t\tor: () => Ok(result),\n\t\torElse: () => Ok(result),\n\t};\n\n\treturn self;\n}\n\n/**\n * @param err The error value\n * @returns The error result\n *\n * https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err\n */\nexport function Err<R, E>(err: E): Result<R, E> {\n\tconst self: Result<R, E> = {\n\t\tisOk: () => false,\n\t\tisOkAnd: () => false,\n\t\tisErr: () => true,\n\t\tisErrAnd: (fn) => fn(err),\n\t\tok: () => None(),\n\t\terr: () => Some(err),\n\t\tmap: () => Err(err),\n\t\tmapOr: (defaultValue) => defaultValue,\n\t\tmapOrElse: (getDefaultValue) => getDefaultValue(err),\n\t\tmapErr: (fn) => Err(fn(err)),\n\t\texpect: (msg) => {\n\t\t\tthrow new Error(msg);\n\t\t},\n\t\texpectErr: () => err,\n\t\tunwrap: () => {\n\t\t\tthrow new Error(`${err}`);\n\t\t},\n\t\tunwrapErr: () => err,\n\t\tunwrapOr: (defaultValue) => defaultValue,\n\t\tunwrapOrElse: (getDefaultValue) => getDefaultValue(err),\n\t\tand: () => Err(err),\n\t\tandThen: () => Err(err),\n\t\tor: (res) => res,\n\t\torElse: (getRes) => getRes(err),\n\t};\n\n\treturn self;\n}\n\n/**\n * An implementation of `Option` from Rust stdlib\n *\n * https://doc.rust-lang.org/std/option/enum.Option.html\n */\nexport type Option<T> = Readonly<{\n\t/**\n\t * ```ts\n\t * Some('foo').and(otherOption); // returns `otherOption`\n\t * None().and(otherOption); // returns `None()`\n\t * ```\n\t */\n\tand: <R>(opt: Option<R>) => Option<R>;\n\t/**\n\t * ```ts\n\t * Some(1).andThen((value) => Some(value * 2)); // returns `Some(2)`\n\t * None().andThen((value) => Some(value * 2)); // returns `None()`\n\t * ```\n\t */\n\tandThen: <R>(fn: (arg: T) => Option<R>) => Option<R>;\n\t/**\n\t * ```ts\n\t * Some('foo').expect('error message'); // returns `'foo'`\n\t * None().expect('error message'); // throws `new Error('error message')`\n\t * ```\n\t */\n\texpect: (msg: string) => T;\n\t/**\n\t * ```ts\n\t * Some(123).filter((value) => value > 100); // returns `Some(123)`\n\t * Some(12).filter((value) => value > 100); // returns `None()`\n\t * None().filter((value) => value > 100); // returns `None()`\n\t * ```\n\t */\n\tfilter: (fn: (arg: T) => boolean) => Option<T>;\n\t/**\n\t * ```ts\n\t * Some('foo').isSome(); // returns `true`\n\t * None().isSome(); // returns `false`\n\t * ```\n\t */\n\tisSome: () => boolean;\n\t/**\n\t * ```ts\n\t * Some(123).isSomeAnd((value) => value > 100); // returns `true`\n\t * Some(12).isSomeAnd((value) => value > 100); // returns `false`\n\t * None().isSomeAnd((value) => value > 100); // returns `false`\n\t * ```\n\t */\n\tisSomeAnd: (fn: (arg: T) => boolean) => boolean;\n\t/**\n\t * ```ts\n\t * Some('foo').isNone(); // returns `false`\n\t * None().isNone(); // returns `true`\n\t * ```\n\t */\n\tisNone: () => boolean;\n\t/**\n\t * ```ts\n\t * Some(1).map((value) => Some(value * 2)); // returns `Some(2)`\n\t * None().map((value) => Some(value * 2)); // returns `None()`\n\t * ```\n\t */\n\tmap: <R>(fn: (arg: T) => R) => Option<R>;\n\t/**\n\t * ```ts\n\t * Some(1).mapOr(10, (value) => Some(value * 2)); // returns `2`\n\t * None().mapOr(10, (value) => Some(value * 2)); // returns `10`\n\t * ```\n\t */\n\tmapOr: <R>(defaultValue: R, fn: (arg: T) => R) => R;\n\t/**\n\t * ```ts\n\t * Some(1).mapOrElse(() => 10, (value) => Some(value * 2)); // returns `2`\n\t * None().mapOrElse(() => 10, (value) => Some(value * 2)); // returns `10`\n\t * ```\n\t */\n\tmapOrElse: <R>(getDefaultValue: () => R, fn: (arg: T) => R) => R;\n\t/**\n\t * ```ts\n\t * Some('foo').okOr('err'); // returns `Ok('foo')`\n\t * None().okOr('err'); // returns `Err('err')`\n\t * ```\n\t */\n\tokOr: <E>(err: E) => Result<T, E>;\n\t/**\n\t * ```ts\n\t * Some('foo').okOrElse(() => 'err'); // returns `Ok('foo')`\n\t * None().okOrElse(() => 'err'); // returns `Err('err')`\n\t * ```\n\t */\n\tokOrElse: <E>(getErr: () => E) => Result<T, E>;\n\t/**\n\t * ```ts\n\t * Some('foo').or(otherOption); // returns `Some('foo')`\n\t * None().or(otherOption); // returns `otherOption`\n\t * ```\n\t */\n\tor: (opt: Option<T>) => Option<T>;\n\t/**\n\t * ```ts\n\t * Some('foo').or(() => Some('bar')); // returns `Some('foo')`\n\t * None().or(() => Some('bar')); // returns `Some('bar')`\n\t * None().or(() => None()); // returns `None()`\n\t * ```\n\t */\n\torElse: (fn: () => Option<T>) => Option<T>;\n\t/**\n\t * ```ts\n\t * Some('foo').unwrap(); // returns `'foo'`\n\t * None().unwrap(); // throws\n\t * ```\n\t */\n\tunwrap: () => T;\n\t/**\n\t * ```ts\n\t * Some('foo').unwrapOr('bar'); // returns `'foo'`\n\t * None().unwrapOr('bar'); // returns `'bar'`\n\t * ```\n\t */\n\tunwrapOr: (defaultValue: T) => T;\n\t/**\n\t * ```ts\n\t * Some('foo').unwrapOrElse(() => 'bar'); // returns `'foo'`\n\t * None().unwrapOrElse(() => 'bar'); // returns `'bar'`\n\t * ```\n\t */\n\tunwrapOrElse: (getDefaultValue: () => T) => T;\n\t/**\n\t * ```ts\n\t * Some('foo').xor(Some('bar')); // returns `None()`\n\t * Some('foo').xor(None()); // returns `Some('foo')`\n\t * None().xor(Some('bar')); // returns `Some('bar')`\n\t * None().xor(None()); // returns `None()`\n\t * ```\n\t */\n\txor: (opt: Option<T>) => Option<T>;\n}>;\n\n/**\n * https://doc.rust-lang.org/std/option/enum.Option.html#variant.None\n *\n * @returns Empty option\n */\nexport function None<T>(): Option<T> {\n\tconst self: Option<T> = {\n\t\tand: () => None(),\n\t\tandThen: () => None(),\n\t\texpect: (msg: string) => {\n\t\t\tthrow new Error(msg);\n\t\t},\n\t\tfilter: () => self,\n\t\tisSome: () => false,\n\t\tisSomeAnd: () => false,\n\t\tisNone: () => true,\n\t\tmap: () => None(),\n\t\tmapOr: (defaultValue) => defaultValue,\n\t\tmapOrElse: (getDefaultValue) => getDefaultValue(),\n\t\tokOr: (err) => Err(err),\n\t\tokOrElse: (getErr) => Err(getErr()),\n\t\tor: (opt) => opt,\n\t\torElse: (fn) => fn(),\n\t\tunwrap: () => {\n\t\t\tthrow new Error(\"panic! call `unwrap` on a `None` value\");\n\t\t},\n\t\tunwrapOr: (defaultValue) => defaultValue,\n\t\tunwrapOrElse: (getDefaultValue) => getDefaultValue(),\n\t\txor: (opt) => {\n\t\t\tif (opt.isSome()) {\n\t\t\t\treturn opt;\n\t\t\t}\n\n\t\t\treturn self;\n\t\t},\n\t};\n\n\treturn self;\n}\n\n/**\n * @param value Some value\n * @returns Filled option\n *\n * https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some\n */\nexport function Some<T>(value: T): Option<T> {\n\tconst self: Option<T> = {\n\t\tand: (opt) => opt,\n\t\tandThen: (fn) => fn(value),\n\t\texpect: () => value,\n\t\tfilter: (fn) => {\n\t\t\tif (fn(value)) {\n\t\t\t\treturn self;\n\t\t\t}\n\n\t\t\treturn None();\n\t\t},\n\t\tisSome: () => true,\n\t\tisSomeAnd: (fn) => fn(value),\n\t\tisNone: () => false,\n\t\tmap: (fn) => Some(fn(value)),\n\t\tmapOr: (_, fn) => fn(value),\n\t\tmapOrElse: (_, fn) => fn(value),\n\t\tokOr: () => Ok(value),\n\t\tokOrElse: () => Ok(value),\n\t\tor: () => self,\n\t\torElse: () => self,\n\t\tunwrap: () => value,\n\t\tunwrapOr: () => value,\n\t\tunwrapOrElse: () => value,\n\t\txor: (opt) => {\n\t\t\tif (opt.isNone()) {\n\t\t\t\treturn self;\n\t\t\t}\n\n\t\t\treturn None();\n\t\t},\n\t};\n\n\treturn self;\n}\n","import { None, type Option, Some } from \"./option_result\";\n\n/**\n * Convert a nullable variable to `Option`\n * @param arg nullable variable\n * @returns Option\n *\n * ```\n * const option = toOption('foo');\n * option.isNone(); // returns `false`;\n * option.unwrap(); // returns `'foo'`;\n *\n * toOption(null).isNone(); // returns `true`\n * toOption(undefined).isNone(); // returns `true`\n * ```\n */\nexport function toOption<T>(arg: T | null | undefined): Option<T> {\n\tif (arg === null || arg === undefined) {\n\t\treturn None();\n\t}\n\n\treturn Some<T>(arg);\n}\n","import { Err, Ok, type Result } from \"./option_result\";\n\n/**\n * Converts `Promise` to `Result`\n * @param promise target `Promise`\n * @returns success result for resolved promise or error result for rejected promise\n *\n * ```ts\n * const successResult = await getResult(Promise.resolve('foo'));\n * successResult.unwrap(); // returns 'foo'\n *\n * const errorResult = await getResult(Promise.reject('bar'));\n * errorResult.unwrapErr(); // returns 'bar'\n * ```\n */\nexport function getResult<R, E>(promise: Promise<R>): Promise<Result<R, E>> {\n\treturn promise.then(\n\t\t(response) => Ok(response),\n\t\t(err) => Err(err),\n\t);\n}\n","/**\n * Panics if the value is `null` or `undefined` or returns it otherwise\n * @param value Target value\n * @returns Unchanged value\n * @throws If the value is `null` or `undefined`\n *\n * ```ts\n * const fooOrUndefined = document.getElementById('foo'); // html element or `undefined`\n * const foo = unwrap(fooOrUndefined); // exactly html element\n * ```\n */\nexport function unwrap<T>(value: T | null | undefined): T {\n\tif (value === null || value === undefined) {\n\t\tthrow new Error(`panic! call \\`unwrap\\` on a \\`${value}\\` value`);\n\t}\n\n\treturn value;\n}\n","/**\n * Returns the value if it's not `null` or `undefined`, or returns the default value\n * @param value Target value\n * @returns Unchanged value if it's not `null` or `undefined` or the default value\n *\n * ```ts\n * const foo: Partial<Record<string, string>> = { bar: 'baz' };\n *\n * unwrapOr(foo.bar, 'qux'); // returns 'baz'\n * unwrapOr(foo.bat, 'qux'); // returns 'qux'\n * ```\n */\nexport function unwrapOr<T>(value: T | null | undefined, defaultValue: T): T {\n\tif (value === null || value === undefined) {\n\t\treturn defaultValue;\n\t}\n\n\treturn value;\n}\n","/**\n * Returns the value if it's not `null` or `undefined`, or computes it\n * @param value Target value\n * @returns Unchanged value if it's not `null` or `undefined` or the computed value\n *\n * ```ts\n * const foo: Partial<Record<string, string>> = { bar: 'baz' };\n *\n * unwrapOrElse(foo.bar, () => 'qux'); // returns 'baz'\n * unwrapOrElse(foo.bat, () => 'qux'); // returns 'qux'\n * ```\n */\nexport function unwrapOrElse<T>(\n\tvalue: T | null | undefined,\n\tgetDefaultValue: () => T,\n): T {\n\tif (value === null || value === undefined) {\n\t\treturn getDefaultValue();\n\t}\n\n\treturn value;\n}\n"],"mappings":"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","names":[]}