{"ast":null,"code":"// src/option_result.ts\nfunction Ok(result) {\n  const self = {\n    isOk: () => true,\n    isOkAnd: fn => fn(result),\n    isErr: () => false,\n    isErrAnd: () => false,\n    ok: () => Some(result),\n    err: () => None(),\n    map: fn => Ok(fn(result)),\n    mapOr: (_, fn) => fn(result),\n    mapOrElse: (_, fn) => fn(result),\n    mapErr: () => Ok(result),\n    expect: () => result,\n    expectErr: msg => {\n      throw new Error(msg);\n    },\n    unwrap: () => result,\n    unwrapErr: () => {\n      throw new Error(`${result}`);\n    },\n    unwrapOr: () => result,\n    unwrapOrElse: () => result,\n    and: res => res,\n    andThen: getRes => getRes(result),\n    or: () => Ok(result),\n    orElse: () => Ok(result)\n  };\n  return self;\n}\nfunction Err(err) {\n  const self = {\n    isOk: () => false,\n    isOkAnd: () => false,\n    isErr: () => true,\n    isErrAnd: fn => fn(err),\n    ok: () => None(),\n    err: () => Some(err),\n    map: () => Err(err),\n    mapOr: defaultValue => defaultValue,\n    mapOrElse: getDefaultValue => getDefaultValue(err),\n    mapErr: fn => Err(fn(err)),\n    expect: msg => {\n      throw new Error(msg);\n    },\n    expectErr: () => err,\n    unwrap: () => {\n      throw new Error(`${err}`);\n    },\n    unwrapErr: () => err,\n    unwrapOr: defaultValue => defaultValue,\n    unwrapOrElse: getDefaultValue => getDefaultValue(err),\n    and: () => Err(err),\n    andThen: () => Err(err),\n    or: res => res,\n    orElse: getRes => getRes(err)\n  };\n  return self;\n}\nfunction None() {\n  const self = {\n    and: () => None(),\n    andThen: () => None(),\n    expect: msg => {\n      throw new Error(msg);\n    },\n    filter: () => self,\n    isSome: () => false,\n    isSomeAnd: () => false,\n    isNone: () => true,\n    map: () => None(),\n    mapOr: defaultValue => defaultValue,\n    mapOrElse: getDefaultValue => getDefaultValue(),\n    okOr: err => Err(err),\n    okOrElse: getErr => Err(getErr()),\n    or: opt => opt,\n    orElse: fn => fn(),\n    unwrap: () => {\n      throw new Error(\"panic! call `unwrap` on a `None` value\");\n    },\n    unwrapOr: defaultValue => defaultValue,\n    unwrapOrElse: getDefaultValue => getDefaultValue(),\n    xor: opt => {\n      if (opt.isSome()) {\n        return opt;\n      }\n      return self;\n    }\n  };\n  return self;\n}\nfunction Some(value) {\n  const self = {\n    and: opt => opt,\n    andThen: fn => fn(value),\n    expect: () => value,\n    filter: fn => {\n      if (fn(value)) {\n        return self;\n      }\n      return None();\n    },\n    isSome: () => true,\n    isSomeAnd: fn => fn(value),\n    isNone: () => false,\n    map: fn => Some(fn(value)),\n    mapOr: (_, fn) => fn(value),\n    mapOrElse: (_, fn) => fn(value),\n    okOr: () => Ok(value),\n    okOrElse: () => Ok(value),\n    or: () => self,\n    orElse: () => self,\n    unwrap: () => value,\n    unwrapOr: () => value,\n    unwrapOrElse: () => value,\n    xor: opt => {\n      if (opt.isNone()) {\n        return self;\n      }\n      return None();\n    }\n  };\n  return self;\n}\n\n// src/to_option.ts\nfunction toOption(arg) {\n  if (arg === null || arg === void 0) {\n    return None();\n  }\n  return Some(arg);\n}\n\n// src/get_result.ts\nfunction getResult(promise) {\n  return promise.then(response => Ok(response), err => Err(err));\n}\n\n// src/unwrap.ts\nfunction unwrap(value) {\n  if (value === null || value === void 0) {\n    throw new Error(`panic! call \\`unwrap\\` on a \\`${value}\\` value`);\n  }\n  return value;\n}\n\n// src/unwrap_or.ts\nfunction unwrapOr(value, defaultValue) {\n  if (value === null || value === void 0) {\n    return defaultValue;\n  }\n  return value;\n}\n\n// src/unwrap_or_else.ts\nfunction unwrapOrElse(value, getDefaultValue) {\n  if (value === null || value === void 0) {\n    return getDefaultValue();\n  }\n  return value;\n}\nexport { Err, None, Ok, Some, getResult, toOption, unwrap, unwrapOr, unwrapOrElse };","map":{"version":3,"names":["Ok","result","self","isOk","isOkAnd","fn","isErr","isErrAnd","ok","Some","err","None","map","mapOr","_","mapOrElse","mapErr","expect","expectErr","msg","Error","unwrap","unwrapErr","unwrapOr","unwrapOrElse","and","res","andThen","getRes","or","orElse","Err","defaultValue","getDefaultValue","filter","isSome","isSomeAnd","isNone","okOr","okOrElse","getErr","opt","xor","value","toOption","arg","getResult","promise","then","response"],"sources":["/Users/mac/FPT Education/React JS/React Project/weather/node_modules/krustykrab/src/option_result.ts","/Users/mac/FPT Education/React JS/React Project/weather/node_modules/krustykrab/src/to_option.ts","/Users/mac/FPT Education/React JS/React Project/weather/node_modules/krustykrab/src/get_result.ts","/Users/mac/FPT Education/React JS/React Project/weather/node_modules/krustykrab/src/unwrap.ts","/Users/mac/FPT Education/React JS/React Project/weather/node_modules/krustykrab/src/unwrap_or.ts","/Users/mac/FPT Education/React JS/React Project/weather/node_modules/krustykrab/src/unwrap_or_else.ts"],"sourcesContent":["/**\n * An implementation of `Result` from Rust stdlib\n *\n * https://doc.rust-lang.org/std/result/enum.Result.html\n */\nexport type Result<R, E> = Readonly<{\n\t/**\n\t * ```ts\n\t * Ok('foo').isOk(); // returns `true`\n\t * Err('foo').isOk(); // returns `false`\n\t * ```\n\t */\n\tisOk: () => boolean;\n\t/**\n\t * ```ts\n\t * Ok(123).isOkAnd((value) => value > 100); // returns `true`\n\t * Ok(12).isOkAnd((value) => value > 100); // returns `false`\n\t * Err(123).isOkAnd((value) => value > 100); // returns `false`\n\t * ```\n\t */\n\tisOkAnd: (fn: (arg: R) => boolean) => boolean;\n\t/**\n\t * ```ts\n\t * Ok('foo').isErr(); // returns `false`\n\t * Err('foo').isErr(); // returns `true`\n\t * ```\n\t */\n\tisErr: () => boolean;\n\t/**\n\t * ```ts\n\t * Ok(123).isErrAnd((value) => value > 100); // returns `false`\n\t * Err(123).isErrAnd((value) => value > 100); // returns `true`\n\t * Err(12).isErrAnd((value) => value > 100); // returns `false`\n\t * ```\n\t */\n\tisErrAnd: (fn: (arg: E) => boolean) => boolean;\n\t/**\n\t * ```ts\n\t * Ok('foo').ok(); // returns `Some('foo')`\n\t * Err('foo').ok(); // returns `None()`\n\t * ```\n\t */\n\tok: () => Option<R>;\n\t/**\n\t * ```ts\n\t * Ok('foo').err(); // returns `None()`\n\t * Err('foo').err(); // returns `Some('foo')`\n\t * ```\n\t */\n\terr: () => Option<E>;\n\t/**\n\t * ```ts\n\t * Ok(1).map((value) => value * 2); // returns `Ok(2)`\n\t * Err(1).map((value) => value * 2); // returns `Err(1)`\n\t * ```\n\t */\n\tmap: <U>(fn: (arg: R) => U) => Result<U, E>;\n\t/**\n\t * ```ts\n\t * Ok(1).mapOr(10, (value) => value * 2); // returns `2`\n\t * Err(1).mapOr(10, (value) => value * 2); // returns `10`\n\t * ```\n\t */\n\tmapOr: <U>(defaultValue: U, fn: (arg: R) => U) => U;\n\t/**\n\t * ```ts\n\t * Ok(1).mapOrElse((err) => err * 10, (value) => value * 2); // returns `2`\n\t * Err(1).mapOrElse((err) => err * 10, (value) => value * 2); // returns `10`\n\t * ```\n\t */\n\tmapOrElse: <U>(getDefaultValue: (arg: E) => U, fn: (arg: R) => U) => U;\n\t/**\n\t * ```ts\n\t * Ok(1).mapErr((err) => err * 2); // returns `Ok(1)`\n\t * Err(1).mapErr((err) => err * 2); // returns `Err(2)`\n\t * ```\n\t */\n\tmapErr: <F>(fn: (arg: E) => F) => Result<R, F>;\n\t/**\n\t * ```ts\n\t * Ok('foo').expect('error message'); // returns `'foo'`\n\t * Err('foo').expect('error message'); // throws `new Error('error message')`\n\t * ```\n\t */\n\texpect: (msg: string) => R;\n\t/**\n\t * ```ts\n\t * Ok('foo').expectErr('error message'); // throws `new Error('error message')`\n\t * Err('foo').expectErr('error message'); // returns `'foo'`\n\t * ```\n\t */\n\texpectErr: (msg: string) => E;\n\t/**\n\t * ```ts\n\t * Ok('foo').unwrap(); // returns `'foo'`\n\t * Err('foo').unwrap(); // throws\n\t * ```\n\t */\n\tunwrap: () => R;\n\t/**\n\t * ```ts\n\t * Ok('foo').unwrapErr(); // throws\n\t * Err('foo').unwrapErr(); // returns `'foo'`\n\t * ```\n\t */\n\tunwrapErr: () => E;\n\t/**\n\t * ```ts\n\t * Ok('foo').unwrapOr('bar'); // returns `'foo'`\n\t * Err('foo').unwrapOr('bar'); // returns `'bar'`\n\t * ```\n\t */\n\tunwrapOr: (defaultValue: R) => R;\n\t/**\n\t * ```ts\n\t * Ok(1).unwrapOrElse('bar'); // returns `1`\n\t * Err(1).unwrapOrElse((err) => err * 2); // returns `2`\n\t * ```\n\t */\n\tunwrapOrElse: (getDefaultValue: (arg: E) => R) => R;\n\t/**\n\t * ```ts\n\t * Ok('foo').and(otherResult); // returns `otherResult`\n\t * Err('foo').and(otherResult); // returns `Err('foo')`\n\t * ```\n\t */\n\tand: <U>(res: Result<U, E>) => Result<U, E>;\n\t/**\n\t * ```ts\n\t * Ok(1).andThen((value) => Ok(value * 2)); // returns `Ok(2)`\n\t * Ok(1).andThen((value) => Err(value * 2)); // returns `Err(2)`\n\t * Err(1).andThen((value) => Ok(value * 2)); // returns `Err(1)`\n\t * ```\n\t */\n\tandThen: <U>(getRes: (arg: R) => Result<U, E>) => Result<U, E>;\n\t/**\n\t * ```ts\n\t * Ok('foo').or(otherResult); // returns `Ok('foo').`\n\t * Err('foo').or(otherResult); // returns `otherResult`\n\t * ```\n\t */\n\tor: <F>(res: Result<R, F>) => Result<R, F>;\n\t/**\n\t * ```ts\n\t * Ok(1).orElse((value) => Ok(value * 2)); // returns `Ok(1)`\n\t * Err(1).orElse((value) => Ok(value * 2)); // returns `Ok(2)`\n\t * Err(1).orElse((value) => Err(value * 2)); // returns `Err(2)`\n\t * ```\n\t */\n\torElse: <F>(getRes: (arg: E) => Result<R, F>) => Result<R, F>;\n}>;\n\n/**\n * @param result The success value\n * @returns The success result\n *\n * https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok\n */\nexport function Ok<R, E>(result: R): Result<R, E> {\n\tconst self: Result<R, E> = {\n\t\tisOk: () => true,\n\t\tisOkAnd: (fn) => fn(result),\n\t\tisErr: () => false,\n\t\tisErrAnd: () => false,\n\t\tok: () => Some(result),\n\t\terr: () => None(),\n\t\tmap: (fn) => Ok(fn(result)),\n\t\tmapOr: (_, fn) => fn(result),\n\t\tmapOrElse: (_, fn) => fn(result),\n\t\tmapErr: () => Ok(result),\n\t\texpect: () => result,\n\t\texpectErr: (msg) => {\n\t\t\tthrow new Error(msg);\n\t\t},\n\t\tunwrap: () => result,\n\t\tunwrapErr: () => {\n\t\t\tthrow new Error(`${result}`);\n\t\t},\n\t\tunwrapOr: () => result,\n\t\tunwrapOrElse: () => result,\n\t\tand: (res) => res,\n\t\tandThen: (getRes) => getRes(result),\n\t\tor: () => Ok(result),\n\t\torElse: () => Ok(result),\n\t};\n\n\treturn self;\n}\n\n/**\n * @param err The error value\n * @returns The error result\n *\n * https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err\n */\nexport function Err<R, E>(err: E): Result<R, E> {\n\tconst self: Result<R, E> = {\n\t\tisOk: () => false,\n\t\tisOkAnd: () => false,\n\t\tisErr: () => true,\n\t\tisErrAnd: (fn) => fn(err),\n\t\tok: () => None(),\n\t\terr: () => Some(err),\n\t\tmap: () => Err(err),\n\t\tmapOr: (defaultValue) => defaultValue,\n\t\tmapOrElse: (getDefaultValue) => getDefaultValue(err),\n\t\tmapErr: (fn) => Err(fn(err)),\n\t\texpect: (msg) => {\n\t\t\tthrow new Error(msg);\n\t\t},\n\t\texpectErr: () => err,\n\t\tunwrap: () => {\n\t\t\tthrow new Error(`${err}`);\n\t\t},\n\t\tunwrapErr: () => err,\n\t\tunwrapOr: (defaultValue) => defaultValue,\n\t\tunwrapOrElse: (getDefaultValue) => getDefaultValue(err),\n\t\tand: () => Err(err),\n\t\tandThen: () => Err(err),\n\t\tor: (res) => res,\n\t\torElse: (getRes) => getRes(err),\n\t};\n\n\treturn self;\n}\n\n/**\n * An implementation of `Option` from Rust stdlib\n *\n * https://doc.rust-lang.org/std/option/enum.Option.html\n */\nexport type Option<T> = Readonly<{\n\t/**\n\t * ```ts\n\t * Some('foo').and(otherOption); // returns `otherOption`\n\t * None().and(otherOption); // returns `None()`\n\t * ```\n\t */\n\tand: <R>(opt: Option<R>) => Option<R>;\n\t/**\n\t * ```ts\n\t * Some(1).andThen((value) => Some(value * 2)); // returns `Some(2)`\n\t * None().andThen((value) => Some(value * 2)); // returns `None()`\n\t * ```\n\t */\n\tandThen: <R>(fn: (arg: T) => Option<R>) => Option<R>;\n\t/**\n\t * ```ts\n\t * Some('foo').expect('error message'); // returns `'foo'`\n\t * None().expect('error message'); // throws `new Error('error message')`\n\t * ```\n\t */\n\texpect: (msg: string) => T;\n\t/**\n\t * ```ts\n\t * Some(123).filter((value) => value > 100); // returns `Some(123)`\n\t * Some(12).filter((value) => value > 100); // returns `None()`\n\t * None().filter((value) => value > 100); // returns `None()`\n\t * ```\n\t */\n\tfilter: (fn: (arg: T) => boolean) => Option<T>;\n\t/**\n\t * ```ts\n\t * Some('foo').isSome(); // returns `true`\n\t * None().isSome(); // returns `false`\n\t * ```\n\t */\n\tisSome: () => boolean;\n\t/**\n\t * ```ts\n\t * Some(123).isSomeAnd((value) => value > 100); // returns `true`\n\t * Some(12).isSomeAnd((value) => value > 100); // returns `false`\n\t * None().isSomeAnd((value) => value > 100); // returns `false`\n\t * ```\n\t */\n\tisSomeAnd: (fn: (arg: T) => boolean) => boolean;\n\t/**\n\t * ```ts\n\t * Some('foo').isNone(); // returns `false`\n\t * None().isNone(); // returns `true`\n\t * ```\n\t */\n\tisNone: () => boolean;\n\t/**\n\t * ```ts\n\t * Some(1).map((value) => Some(value * 2)); // returns `Some(2)`\n\t * None().map((value) => Some(value * 2)); // returns `None()`\n\t * ```\n\t */\n\tmap: <R>(fn: (arg: T) => R) => Option<R>;\n\t/**\n\t * ```ts\n\t * Some(1).mapOr(10, (value) => Some(value * 2)); // returns `2`\n\t * None().mapOr(10, (value) => Some(value * 2)); // returns `10`\n\t * ```\n\t */\n\tmapOr: <R>(defaultValue: R, fn: (arg: T) => R) => R;\n\t/**\n\t * ```ts\n\t * Some(1).mapOrElse(() => 10, (value) => Some(value * 2)); // returns `2`\n\t * None().mapOrElse(() => 10, (value) => Some(value * 2)); // returns `10`\n\t * ```\n\t */\n\tmapOrElse: <R>(getDefaultValue: () => R, fn: (arg: T) => R) => R;\n\t/**\n\t * ```ts\n\t * Some('foo').okOr('err'); // returns `Ok('foo')`\n\t * None().okOr('err'); // returns `Err('err')`\n\t * ```\n\t */\n\tokOr: <E>(err: E) => Result<T, E>;\n\t/**\n\t * ```ts\n\t * Some('foo').okOrElse(() => 'err'); // returns `Ok('foo')`\n\t * None().okOrElse(() => 'err'); // returns `Err('err')`\n\t * ```\n\t */\n\tokOrElse: <E>(getErr: () => E) => Result<T, E>;\n\t/**\n\t * ```ts\n\t * Some('foo').or(otherOption); // returns `Some('foo')`\n\t * None().or(otherOption); // returns `otherOption`\n\t * ```\n\t */\n\tor: (opt: Option<T>) => Option<T>;\n\t/**\n\t * ```ts\n\t * Some('foo').or(() => Some('bar')); // returns `Some('foo')`\n\t * None().or(() => Some('bar')); // returns `Some('bar')`\n\t * None().or(() => None()); // returns `None()`\n\t * ```\n\t */\n\torElse: (fn: () => Option<T>) => Option<T>;\n\t/**\n\t * ```ts\n\t * Some('foo').unwrap(); // returns `'foo'`\n\t * None().unwrap(); // throws\n\t * ```\n\t */\n\tunwrap: () => T;\n\t/**\n\t * ```ts\n\t * Some('foo').unwrapOr('bar'); // returns `'foo'`\n\t * None().unwrapOr('bar'); // returns `'bar'`\n\t * ```\n\t */\n\tunwrapOr: (defaultValue: T) => T;\n\t/**\n\t * ```ts\n\t * Some('foo').unwrapOrElse(() => 'bar'); // returns `'foo'`\n\t * None().unwrapOrElse(() => 'bar'); // returns `'bar'`\n\t * ```\n\t */\n\tunwrapOrElse: (getDefaultValue: () => T) => T;\n\t/**\n\t * ```ts\n\t * Some('foo').xor(Some('bar')); // returns `None()`\n\t * Some('foo').xor(None()); // returns `Some('foo')`\n\t * None().xor(Some('bar')); // returns `Some('bar')`\n\t * None().xor(None()); // returns `None()`\n\t * ```\n\t */\n\txor: (opt: Option<T>) => Option<T>;\n}>;\n\n/**\n * https://doc.rust-lang.org/std/option/enum.Option.html#variant.None\n *\n * @returns Empty option\n */\nexport function None<T>(): Option<T> {\n\tconst self: Option<T> = {\n\t\tand: () => None(),\n\t\tandThen: () => None(),\n\t\texpect: (msg: string) => {\n\t\t\tthrow new Error(msg);\n\t\t},\n\t\tfilter: () => self,\n\t\tisSome: () => false,\n\t\tisSomeAnd: () => false,\n\t\tisNone: () => true,\n\t\tmap: () => None(),\n\t\tmapOr: (defaultValue) => defaultValue,\n\t\tmapOrElse: (getDefaultValue) => getDefaultValue(),\n\t\tokOr: (err) => Err(err),\n\t\tokOrElse: (getErr) => Err(getErr()),\n\t\tor: (opt) => opt,\n\t\torElse: (fn) => fn(),\n\t\tunwrap: () => {\n\t\t\tthrow new Error(\"panic! call `unwrap` on a `None` value\");\n\t\t},\n\t\tunwrapOr: (defaultValue) => defaultValue,\n\t\tunwrapOrElse: (getDefaultValue) => getDefaultValue(),\n\t\txor: (opt) => {\n\t\t\tif (opt.isSome()) {\n\t\t\t\treturn opt;\n\t\t\t}\n\n\t\t\treturn self;\n\t\t},\n\t};\n\n\treturn self;\n}\n\n/**\n * @param value Some value\n * @returns Filled option\n *\n * https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some\n */\nexport function Some<T>(value: T): Option<T> {\n\tconst self: Option<T> = {\n\t\tand: (opt) => opt,\n\t\tandThen: (fn) => fn(value),\n\t\texpect: () => value,\n\t\tfilter: (fn) => {\n\t\t\tif (fn(value)) {\n\t\t\t\treturn self;\n\t\t\t}\n\n\t\t\treturn None();\n\t\t},\n\t\tisSome: () => true,\n\t\tisSomeAnd: (fn) => fn(value),\n\t\tisNone: () => false,\n\t\tmap: (fn) => Some(fn(value)),\n\t\tmapOr: (_, fn) => fn(value),\n\t\tmapOrElse: (_, fn) => fn(value),\n\t\tokOr: () => Ok(value),\n\t\tokOrElse: () => Ok(value),\n\t\tor: () => self,\n\t\torElse: () => self,\n\t\tunwrap: () => value,\n\t\tunwrapOr: () => value,\n\t\tunwrapOrElse: () => value,\n\t\txor: (opt) => {\n\t\t\tif (opt.isNone()) {\n\t\t\t\treturn self;\n\t\t\t}\n\n\t\t\treturn None();\n\t\t},\n\t};\n\n\treturn self;\n}\n","import { None, type Option, Some } from \"./option_result\";\n\n/**\n * Convert a nullable variable to `Option`\n * @param arg nullable variable\n * @returns Option\n *\n * ```\n * const option = toOption('foo');\n * option.isNone(); // returns `false`;\n * option.unwrap(); // returns `'foo'`;\n *\n * toOption(null).isNone(); // returns `true`\n * toOption(undefined).isNone(); // returns `true`\n * ```\n */\nexport function toOption<T>(arg: T | null | undefined): Option<T> {\n\tif (arg === null || arg === undefined) {\n\t\treturn None();\n\t}\n\n\treturn Some<T>(arg);\n}\n","import { Err, Ok, type Result } from \"./option_result\";\n\n/**\n * Converts `Promise` to `Result`\n * @param promise target `Promise`\n * @returns success result for resolved promise or error result for rejected promise\n *\n * ```ts\n * const successResult = await getResult(Promise.resolve('foo'));\n * successResult.unwrap(); // returns 'foo'\n *\n * const errorResult = await getResult(Promise.reject('bar'));\n * errorResult.unwrapErr(); // returns 'bar'\n * ```\n */\nexport function getResult<R, E>(promise: Promise<R>): Promise<Result<R, E>> {\n\treturn promise.then(\n\t\t(response) => Ok(response),\n\t\t(err) => Err(err),\n\t);\n}\n","/**\n * Panics if the value is `null` or `undefined` or returns it otherwise\n * @param value Target value\n * @returns Unchanged value\n * @throws If the value is `null` or `undefined`\n *\n * ```ts\n * const fooOrUndefined = document.getElementById('foo'); // html element or `undefined`\n * const foo = unwrap(fooOrUndefined); // exactly html element\n * ```\n */\nexport function unwrap<T>(value: T | null | undefined): T {\n\tif (value === null || value === undefined) {\n\t\tthrow new Error(`panic! call \\`unwrap\\` on a \\`${value}\\` value`);\n\t}\n\n\treturn value;\n}\n","/**\n * Returns the value if it's not `null` or `undefined`, or returns the default value\n * @param value Target value\n * @returns Unchanged value if it's not `null` or `undefined` or the default value\n *\n * ```ts\n * const foo: Partial<Record<string, string>> = { bar: 'baz' };\n *\n * unwrapOr(foo.bar, 'qux'); // returns 'baz'\n * unwrapOr(foo.bat, 'qux'); // returns 'qux'\n * ```\n */\nexport function unwrapOr<T>(value: T | null | undefined, defaultValue: T): T {\n\tif (value === null || value === undefined) {\n\t\treturn defaultValue;\n\t}\n\n\treturn value;\n}\n","/**\n * Returns the value if it's not `null` or `undefined`, or computes it\n * @param value Target value\n * @returns Unchanged value if it's not `null` or `undefined` or the computed value\n *\n * ```ts\n * const foo: Partial<Record<string, string>> = { bar: 'baz' };\n *\n * unwrapOrElse(foo.bar, () => 'qux'); // returns 'baz'\n * unwrapOrElse(foo.bat, () => 'qux'); // returns 'qux'\n * ```\n */\nexport function unwrapOrElse<T>(\n\tvalue: T | null | undefined,\n\tgetDefaultValue: () => T,\n): T {\n\tif (value === null || value === undefined) {\n\t\treturn getDefaultValue();\n\t}\n\n\treturn value;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}